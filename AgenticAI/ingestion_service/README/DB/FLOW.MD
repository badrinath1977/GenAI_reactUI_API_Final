Excellent ğŸ‘ Badri â€” now weâ€™ll define the **clear execution flow of Tables + Stored Procedures** in your finalized `EnterpriseGenAI` database.

Iâ€™ll explain this in a **system-level architectural way**, so you can present this to Architect/Manager.

---

# ğŸ— OVERALL SYSTEM FLOW (DB Perspective)

We have 3 major flows:

1ï¸âƒ£ File Upload Flow
2ï¸âƒ£ File Replacement Flow
3ï¸âƒ£ RAG Query Flow
4ï¸âƒ£ Error Handling Flow
5ï¸âƒ£ Usage & Prompt Logging Flow

---

# ğŸŸ¢ 1ï¸âƒ£ FILE UPLOAD FLOW (NEW FILE)

### ğŸ¯ Scenario:

User uploads a new document.

---

## ğŸ” Flow Diagram (DB Level)

```
API Layer
   â†“
Generate SHA256 ContentHash
   â†“
sp_GetActiveFileByHash
   â†“
IF EXISTS â†’ STOP (Duplicate Content)
   â†“
sp_GetActiveFileByName
   â†“
IF NOT EXISTS â†’ Insert New File
   â†“
sp_InsertFileMetadata
   â†“
Return NewFileId
```

---

## ğŸ§  Stored Procedures Used

### 1ï¸âƒ£ `sp_GetActiveFileByHash`

Purpose:

* Prevent duplicate content
* Avoid unnecessary vector processing

```sql
EXEC ApplicationChatbot.sp_GetActiveFileByHash @ContentHash
```

---

### 2ï¸âƒ£ `sp_GetActiveFileByName`

Purpose:

* Check if same logical document exists

```sql
EXEC ApplicationChatbot.sp_GetActiveFileByName @FileName
```

---

### 3ï¸âƒ£ `sp_InsertFileMetadata`

Purpose:

* Insert new document metadata
* Returns NewFileId (used for vector tagging)

```sql
EXEC ApplicationChatbot.sp_InsertFileMetadata ...
```

---

# ğŸŸ¡ 2ï¸âƒ£ FILE REPLACEMENT FLOW

### ğŸ¯ Scenario:

Same filename exists but content hash is different.

---

## ğŸ” Flow Diagram

```
Upload Request
   â†“
Generate SHA256
   â†“
sp_GetActiveFileByHash â†’ NOT FOUND
   â†“
sp_GetActiveFileByName â†’ FOUND
   â†“
User Confirms Replace
   â†“
sp_MarkFileInactive (Old File)
   â†“
Vector Delete by FileId
   â†“
sp_InsertFileMetadata (New Version)
   â†“
NewFileId Returned
```

---

## ğŸ§  Stored Procedures Used

### 1ï¸âƒ£ `sp_MarkFileInactive`

Purpose:

* Soft delete old version
* Maintain audit trail

```sql
EXEC ApplicationChatbot.sp_MarkFileInactive
    @FileId = 10,
    @Reason = 'Replaced by newer version'
```

This updates:

```sql
IsActive = 0
InactivatedReason = 'Replaced by newer version'
```

---

# ğŸŸ£ 3ï¸âƒ£ RAG QUERY FLOW

### ğŸ¯ Scenario:

User asks question.

---

## ğŸ” Flow Diagram

```
User Question
   â†“
Vector DB Retrieval (Filter: IsActive=1)
   â†“
LLM Call
   â†“
sp_InsertPromptLog
   â†“
Store question/response/tokens
```

---

## ğŸ§  Stored Procedures Used

### `sp_InsertPromptLog`

```sql
EXEC ApplicationChatbot.sp_InsertPromptLog
    @UserName,
    @Provider,
    @Model,
    @Question,
    @Response,
    @TokensUsed,
    @Department
```

Purpose:

* Audit AI usage
* Track token consumption
* Monitor per user & per model usage

---

# ğŸ”´ 4ï¸âƒ£ ERROR FLOW

### ğŸ¯ Scenario:

Any exception in upload/query.

---

## ğŸ” Flow Diagram

```
Exception Occurs
   â†“
Middleware catches
   â†“
sp_InsertErrorLog
   â†“
Flat file logging
   â†“
Return TraceId to user
```

---

## ğŸ§  Stored Procedure Used

### `sp_InsertErrorLog`

```sql
EXEC ApplicationChatbot.sp_InsertErrorLog
    @TraceId,
    @UserId,
    @ErrorType,
    @ErrorMessage,
    @StackTrace
```

Purpose:

* Centralized error tracking
* Correlation using TraceId
* Enterprise audit compliance

---

# ğŸ”µ 5ï¸âƒ£ USAGE MONITORING FLOW

For dashboard / reporting:

### System Usage

```sql
EXEC ApplicationChatbot.sp_GetSystemUsage
```

Returns:

* TotalRequests
* TotalTokens
* Per Model
* Per Provider

---

### User Usage

```sql
EXEC ApplicationChatbot.sp_GetUserUsage @UserName
```

Purpose:

* Billing
* Rate limiting
* Governance

---

# ğŸ› TABLE ROLE SUMMARY

| Table                   | Purpose                       |
| ----------------------- | ----------------------------- |
| FileMetadata            | Document lifecycle management |
| application_logs        | Request/Response logging      |
| ErrorLog                | Exception tracking            |
| PromptLog               | AI usage tracking             |
| EmbeddingProviderConfig | Embedding provider config     |
| LLMProviderConfig       | LLM config                    |
| SensitiveDataRules      | Data masking rules            |
| SensitiveAudit          | Sensitive detection audit     |

---

# ğŸ”¥ FULL END-TO-END ENTERPRISE FLOW

```
Upload File
   â†“
ContentHash Generated
   â†“
Check Duplicate (Hash)
   â†“
Check Logical Document (Name)
   â†“
Replace or Insert
   â†“
Vector Tagging by FileId
   â†“
User Query
   â†“
Retrieve Only Active File Vectors
   â†“
LLM
   â†“
PromptLog Stored
   â†“
Errors Stored (If Any)
```

---

# ğŸ¯ WHY THIS DB DESIGN IS STRONG

âœ” Deterministic duplicate detection
âœ” Logical document grouping
âœ” Soft delete audit trail
âœ” TraceId based monitoring
âœ” No physical data loss
âœ” Enterprise governance ready
âœ” Supports vector lifecycle
âœ” Supports AI billing monitoring

---

# ğŸ† ARCHITECT SUMMARY YOU CAN PRESENT

We implemented a deterministic content-hash-based document lifecycle strategy. The database ensures strict version control, soft deletion for audit compliance, and selective vector lifecycle management. RAG retrieval only operates on active documents, preventing hallucination from outdated content while maintaining full historical traceability.

---

# ğŸš€ NEXT STEP

Now that DB flow is finalized:

Do you want me to:

1ï¸âƒ£ Map this DB flow to Python repository layer with full transaction handling?
2ï¸âƒ£ Create sequence diagram for presentation?
3ï¸âƒ£ Create API contract document?
4ï¸âƒ£ Move to vector lifecycle finalization?

Tell me the next layer to finalize.
